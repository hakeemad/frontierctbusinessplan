"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@replit+database@3.0.1";
exports.ids = ["vendor-chunks/@replit+database@3.0.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@replit+database@3.0.1/node_modules/@replit/database/dist/index.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@replit+database@3.0.1/node_modules/@replit/database/dist/index.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Client)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n// src/index.ts\n\n\n// src/result.ts\nfunction Err(error, errorExtras) {\n  return { ok: false, error, errorExtras };\n}\nfunction Ok(value) {\n  return { ok: true, value };\n}\n\n// src/index.ts\nvar Client = class {\n  _dbUrl;\n  // use this.dbUrl internally\n  lastDbUrlRefreshTime;\n  /**\n   * Initiates Class.\n   * @param {String} dbUrl Custom database URL\n   */\n  constructor(dbUrl) {\n    if (dbUrl) {\n      this._dbUrl = dbUrl;\n    } else {\n      this._dbUrl = getDbUrl();\n      this.lastDbUrlRefreshTime = Date.now();\n    }\n  }\n  get dbUrl() {\n    if (!this.lastDbUrlRefreshTime) {\n      return this._dbUrl;\n    }\n    if (Date.now() < this.lastDbUrlRefreshTime + 1e3 * 60 * 60) {\n      return this._dbUrl;\n    }\n    this._dbUrl = getDbUrl();\n    this.lastDbUrlRefreshTime = Date.now();\n    return this._dbUrl;\n  }\n  /**\n   * Gets a key\n   * @param {String} key Key\n   * @param {boolean} [options.raw=false] Makes it so that we return the raw string value. Default is false.\n   */\n  async get(key, options) {\n    const response = await doFetch({\n      urlPath: `${this.dbUrl}/${encodeURIComponent(key)}`\n    });\n    if (!response.ok) {\n      return Err(response.error);\n    }\n    const text = await response.value.text();\n    if (options && options.raw) {\n      return Ok(text);\n    }\n    if (!text) {\n      return Ok(null);\n    }\n    try {\n      const parsed = JSON.parse(text);\n      return Ok(parsed === null || parsed === void 0 ? null : parsed);\n    } catch {\n      return Err({\n        message: `Failed to parse value of ${key}, try passing a raw option to get the raw value`\n      });\n    }\n  }\n  /**\n   * Sets a key\n   * @param {String} key Key\n   * @param {any} value Value\n   */\n  async set(key, value) {\n    const strValue = JSON.stringify(value);\n    const response = await doFetch({\n      urlPath: this.dbUrl,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n      body: encodeURIComponent(key) + \"=\" + encodeURIComponent(strValue)\n    });\n    if (response.ok) {\n      return Ok(this);\n    } else {\n      return Err(response.error);\n    }\n  }\n  /**\n   * Deletes a key\n   * @param {String} key Key\n   */\n  async delete(key) {\n    const response = await doFetch({\n      urlPath: `${this.dbUrl}/${encodeURIComponent(key)}`,\n      method: \"DELETE\"\n    });\n    if (response.ok) {\n      return Ok(this);\n    } else {\n      return Err(response.error);\n    }\n  }\n  /**\n   * List key starting with a prefix if provided. Otherwise list all keys.\n   * @param {String} prefix The prefix to filter by.\n   */\n  async list(prefix = \"\") {\n    const response = await doFetch({\n      urlPath: `${this.dbUrl}?encode=true&prefix=${encodeURIComponent(prefix)}`\n    });\n    if (!response.ok) {\n      return Err(response.error);\n    }\n    const text = await response.value.text();\n    if (!text.length) {\n      return Ok([]);\n    }\n    return Ok(text.split(\"\\n\").map(decodeURIComponent));\n  }\n  /**\n   * Clears the database.\n   * @returns a Promise containing this\n   */\n  async empty() {\n    const keys = await this.list();\n    if (!keys.ok) {\n      return Err(keys.error);\n    }\n    const promises = [];\n    for (const key of keys.value) {\n      promises.push(this.delete(key));\n    }\n    const response = await Promise.all(promises);\n    const errors = response.filter((r) => !r.ok).map((r) => r.error);\n    if (errors.length) {\n      return Err({ message: \"Failed to empty databse\" }, errors);\n    }\n    return Ok(this);\n  }\n  /**\n   * Get all key/value pairs and return as an object\n   * @param {boolean} [options.raw=false] Makes it so that we return the raw\n   * string value for each key. Default is false.\n   */\n  async getAll(options) {\n    const keys = await this.list();\n    if (!keys.ok) {\n      return Err(keys.error);\n    }\n    let output = {};\n    for (const key of keys.value) {\n      const value = await this.get(key, options);\n      if (!value.ok) {\n        return Err(value.error);\n      }\n      output[key] = value.value;\n    }\n    return Ok(output);\n  }\n  /**\n   * Sets multiple keys from an object.\n   * @param {Object} obj The object.\n   */\n  async setMultiple(obj) {\n    const promises = [];\n    for (const key in obj) {\n      let val = obj[key];\n      promises.push(this.set(key, val));\n    }\n    const response = await Promise.all(promises);\n    const errors = response.filter((r) => !r.ok).map((r) => r.error);\n    if (errors.length) {\n      return Err({ message: \"Failed to set multiple\" }, errors);\n    }\n    return Ok(this);\n  }\n  /**\n   * Delete multiple entries by key.\n   * @param {Array<string>} args Keys\n   */\n  async deleteMultiple(...args) {\n    const promises = [];\n    for (const arg of args) {\n      promises.push(this.delete(arg));\n    }\n    const response = await Promise.all(promises);\n    const errors = response.filter((r) => !r.ok).map((r) => r.error);\n    if (errors.length) {\n      return Err({ message: \"Failed to delete keys\" }, errors);\n    }\n    return Ok(this);\n  }\n};\nasync function doFetch({\n  urlPath,\n  ...rest\n}) {\n  try {\n    const response = await fetch(new URL(urlPath), rest);\n    if (response.status !== 200 && response.status !== 204) {\n      return Err({\n        message: await response.text(),\n        statusCode: response.status\n      });\n    }\n    return Ok(response);\n  } catch (e) {\n    return Err({ message: e instanceof Error ? e.message : \"unknown error\" });\n  }\n}\nvar replitDBFilename = \"/tmp/replitdb\";\nfunction getDbUrl() {\n  let dbUrl;\n  try {\n    dbUrl = (0,fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync)(replitDBFilename, \"utf8\");\n  } catch (err) {\n    dbUrl = process.env.REPLIT_DB_URL;\n  }\n  if (!dbUrl) {\n    throw new Error(\"expected dbUrl, got undefined\");\n  }\n  return dbUrl;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlcGxpdCtkYXRhYmFzZUAzLjAuMS9ub2RlX21vZHVsZXMvQHJlcGxpdC9kYXRhYmFzZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ2tDOztBQUVsQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyx3QkFBd0I7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQXFEO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxHQUFHLHdCQUF3QjtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsc0JBQXNCLDJCQUEyQjtBQUM5RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSixpQkFBaUIsMkRBQTJEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQVk7QUFDeEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzLy5wbnBtL0ByZXBsaXQrZGF0YWJhc2VAMy4wLjEvbm9kZV9tb2R1bGVzL0ByZXBsaXQvZGF0YWJhc2UvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tIFwiZnNcIjtcblxuLy8gc3JjL3Jlc3VsdC50c1xuZnVuY3Rpb24gRXJyKGVycm9yLCBlcnJvckV4dHJhcykge1xuICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yLCBlcnJvckV4dHJhcyB9O1xufVxuZnVuY3Rpb24gT2sodmFsdWUpIHtcbiAgcmV0dXJuIHsgb2s6IHRydWUsIHZhbHVlIH07XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIENsaWVudCA9IGNsYXNzIHtcbiAgX2RiVXJsO1xuICAvLyB1c2UgdGhpcy5kYlVybCBpbnRlcm5hbGx5XG4gIGxhc3REYlVybFJlZnJlc2hUaW1lO1xuICAvKipcbiAgICogSW5pdGlhdGVzIENsYXNzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGJVcmwgQ3VzdG9tIGRhdGFiYXNlIFVSTFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGJVcmwpIHtcbiAgICBpZiAoZGJVcmwpIHtcbiAgICAgIHRoaXMuX2RiVXJsID0gZGJVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RiVXJsID0gZ2V0RGJVcmwoKTtcbiAgICAgIHRoaXMubGFzdERiVXJsUmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuICBnZXQgZGJVcmwoKSB7XG4gICAgaWYgKCF0aGlzLmxhc3REYlVybFJlZnJlc2hUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGJVcmw7XG4gICAgfVxuICAgIGlmIChEYXRlLm5vdygpIDwgdGhpcy5sYXN0RGJVcmxSZWZyZXNoVGltZSArIDFlMyAqIDYwICogNjApIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYlVybDtcbiAgICB9XG4gICAgdGhpcy5fZGJVcmwgPSBnZXREYlVybCgpO1xuICAgIHRoaXMubGFzdERiVXJsUmVmcmVzaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB0aGlzLl9kYlVybDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gTWFrZXMgaXQgc28gdGhhdCB3ZSByZXR1cm4gdGhlIHJhdyBzdHJpbmcgdmFsdWUuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqL1xuICBhc3luYyBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkb0ZldGNoKHtcbiAgICAgIHVybFBhdGg6IGAke3RoaXMuZGJVcmx9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9YFxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiBFcnIocmVzcG9uc2UuZXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudmFsdWUudGV4dCgpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmF3KSB7XG4gICAgICByZXR1cm4gT2sodGV4dCk7XG4gICAgfVxuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIE9rKG51bGwpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgIHJldHVybiBPayhwYXJzZWQgPT09IG51bGwgfHwgcGFyc2VkID09PSB2b2lkIDAgPyBudWxsIDogcGFyc2VkKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBFcnIoe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIHBhcnNlIHZhbHVlIG9mICR7a2V5fSwgdHJ5IHBhc3NpbmcgYSByYXcgb3B0aW9uIHRvIGdldCB0aGUgcmF3IHZhbHVlYFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBWYWx1ZVxuICAgKi9cbiAgYXN5bmMgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRvRmV0Y2goe1xuICAgICAgdXJsUGF0aDogdGhpcy5kYlVybCxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfSxcbiAgICAgIGJvZHk6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyVmFsdWUpXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICByZXR1cm4gT2sodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFcnIocmVzcG9uc2UuZXJyb3IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG9GZXRjaCh7XG4gICAgICB1cmxQYXRoOiBgJHt0aGlzLmRiVXJsfS8ke2VuY29kZVVSSUNvbXBvbmVudChrZXkpfWAsXG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiBPayh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVycihyZXNwb25zZS5lcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMaXN0IGtleSBzdGFydGluZyB3aXRoIGEgcHJlZml4IGlmIHByb3ZpZGVkLiBPdGhlcndpc2UgbGlzdCBhbGwga2V5cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGZpbHRlciBieS5cbiAgICovXG4gIGFzeW5jIGxpc3QocHJlZml4ID0gXCJcIikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG9GZXRjaCh7XG4gICAgICB1cmxQYXRoOiBgJHt0aGlzLmRiVXJsfT9lbmNvZGU9dHJ1ZSZwcmVmaXg9JHtlbmNvZGVVUklDb21wb25lbnQocHJlZml4KX1gXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgcmV0dXJuIEVycihyZXNwb25zZS5lcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS52YWx1ZS50ZXh0KCk7XG4gICAgaWYgKCF0ZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE9rKFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIE9rKHRleHQuc3BsaXQoXCJcXG5cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGRhdGFiYXNlLlxuICAgKiBAcmV0dXJucyBhIFByb21pc2UgY29udGFpbmluZyB0aGlzXG4gICAqL1xuICBhc3luYyBlbXB0eSgpIHtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5saXN0KCk7XG4gICAgaWYgKCFrZXlzLm9rKSB7XG4gICAgICByZXR1cm4gRXJyKGtleXMuZXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMudmFsdWUpIHtcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy5kZWxldGUoa2V5KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGNvbnN0IGVycm9ycyA9IHJlc3BvbnNlLmZpbHRlcigocikgPT4gIXIub2spLm1hcCgocikgPT4gci5lcnJvcik7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBFcnIoeyBtZXNzYWdlOiBcIkZhaWxlZCB0byBlbXB0eSBkYXRhYnNlXCIgfSwgZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9rKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGtleS92YWx1ZSBwYWlycyBhbmQgcmV0dXJuIGFzIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhdz1mYWxzZV0gTWFrZXMgaXQgc28gdGhhdCB3ZSByZXR1cm4gdGhlIHJhd1xuICAgKiBzdHJpbmcgdmFsdWUgZm9yIGVhY2gga2V5LiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWxsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5saXN0KCk7XG4gICAgaWYgKCFrZXlzLm9rKSB7XG4gICAgICByZXR1cm4gRXJyKGtleXMuZXJyb3IpO1xuICAgIH1cbiAgICBsZXQgb3V0cHV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cy52YWx1ZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmdldChrZXksIG9wdGlvbnMpO1xuICAgICAgaWYgKCF2YWx1ZS5vaykge1xuICAgICAgICByZXR1cm4gRXJyKHZhbHVlLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dFtrZXldID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPayhvdXRwdXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIG11bHRpcGxlIGtleXMgZnJvbSBhbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNldE11bHRpcGxlKG9iaikge1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBsZXQgdmFsID0gb2JqW2tleV07XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2V0KGtleSwgdmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGNvbnN0IGVycm9ycyA9IHJlc3BvbnNlLmZpbHRlcigocikgPT4gIXIub2spLm1hcCgocikgPT4gci5lcnJvcik7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBFcnIoeyBtZXNzYWdlOiBcIkZhaWxlZCB0byBzZXQgbXVsdGlwbGVcIiB9LCBlcnJvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gT2sodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBtdWx0aXBsZSBlbnRyaWVzIGJ5IGtleS5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhcmdzIEtleXNcbiAgICovXG4gIGFzeW5jIGRlbGV0ZU11bHRpcGxlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy5kZWxldGUoYXJnKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGNvbnN0IGVycm9ycyA9IHJlc3BvbnNlLmZpbHRlcigocikgPT4gIXIub2spLm1hcCgocikgPT4gci5lcnJvcik7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBFcnIoeyBtZXNzYWdlOiBcIkZhaWxlZCB0byBkZWxldGUga2V5c1wiIH0sIGVycm9ycyk7XG4gICAgfVxuICAgIHJldHVybiBPayh0aGlzKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRvRmV0Y2goe1xuICB1cmxQYXRoLFxuICAuLi5yZXN0XG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChuZXcgVVJMKHVybFBhdGgpLCByZXN0KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgIHJldHVybiBFcnIoe1xuICAgICAgICBtZXNzYWdlOiBhd2FpdCByZXNwb25zZS50ZXh0KCksXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPayhyZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gRXJyKHsgbWVzc2FnZTogZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogXCJ1bmtub3duIGVycm9yXCIgfSk7XG4gIH1cbn1cbnZhciByZXBsaXREQkZpbGVuYW1lID0gXCIvdG1wL3JlcGxpdGRiXCI7XG5mdW5jdGlvbiBnZXREYlVybCgpIHtcbiAgbGV0IGRiVXJsO1xuICB0cnkge1xuICAgIGRiVXJsID0gcmVhZEZpbGVTeW5jKHJlcGxpdERCRmlsZW5hbWUsIFwidXRmOFwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGJVcmwgPSBwcm9jZXNzLmVudi5SRVBMSVRfREJfVVJMO1xuICB9XG4gIGlmICghZGJVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBkYlVybCwgZ290IHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gZGJVcmw7XG59XG5leHBvcnQge1xuICBDbGllbnQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@replit+database@3.0.1/node_modules/@replit/database/dist/index.mjs\n");

/***/ })

};
;